(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  const savedEvents = [];

    /**
     * Naively checks if a given event name is a native event.
     * @param {String} event Name of the event to test
     * @returns {Boolean}
     */
    const isNativeEvent = event => typeof document[`on${event}`] !== "undefined";

    /**
     * Checks if an event target is our intended target to call the handler for.
     * @param {HTMLElement} eventTarget Target passed from event.
     * @param {String} delegatedTarget Selector of a delegation target.
     * @param {HTMLElement} originalTarget "Main" (non delegated) target.
     * @returns {Boolean}
     */
    const isTarget = (eventTarget, delegatedTarget, originalTarget) => {
      /**
       * If no delegate passed, then the event must have been called on
       * on the original target or its descendents. No questions asked.
       */
      if (!delegatedTarget || typeof delegatedTarget !== "string") {
        return true;
      }

      /**
       * True if:
       * 1. The event target matches the delegate target
       * 2. The event target is a descendent of the delegate target.
       */
      return (
        matches(eventTarget, delegatedTarget) ||
        originalTarget.contains(eventTarget.closest(delegatedTarget))
      );
    };

    /**
     * Checks that a given element complies with a supplied selector.
     * @param {HTMLElement} target Target element to test.
     * @param {String} selector Selector to test the element with.
     * @returns {Boolean}
     */
    const matches = (target, selector) => {
      if (!target) {
        return false;
      }

      if (typeof target.matches === "function") {
        return target.matches(selector);
      } else if (typeof target.msMatchesSelector === "function") {
        return target.msMatchesSelector(selector);
      }

      return false;
    };

    /**
     * Generates a list of nodes from a selector or an EventTarget.
     * @param {*} nodes
     * @returns {Array<EventTarget>}
     */
    const parseNode = nodes => {
      if (!nodes) {
        return [];
      }

      if (typeof nodes === "string") {
        return [...document.querySelectorAll(nodes)];
      } else if (nodes instanceof NodeList) {
        return [...nodes];
      } else if (typeof nodes.addEventListener === "function") {
        return [nodes];
      }

      return [];
    };

    /**
     * Splits a string by ' ' and removes duplicates.
     * @param {String} events
     * @returns {Array<String>}
     */
    const splitEvents = events => {
      if (typeof events !== "string") {
        return [];
      }

      const uniqueEvents = events.split(" ").reduce(
        ({ keys, existing }, current) => {
          if (existing[current]) {
            return { keys, existing };
          }

          return {
            keys: [...keys, current],
            existing: { ...existing, [current]: true }
          };
        },
        { keys: [], existing: {} }
      );

      return uniqueEvents.keys;
    };

    /**
     * Registers either a one time or a permanent listener on an EventTarget.
     * @param {EventTarget} target Target to add listener to.
     * @param {String} eventName Name of the event to listen to.
     * @param {Function} handler Handler callback function.
     * @param {Object} options.
     * @param {String} options.delegate Selector for delegation.
     * @param {Boolean} options.once Determines whether the handler should run once or more.
     */
    const listen = (target, eventName, handler, { delegate, once }) => {
      // Instead of using the user's own handler, we wrap it with our own.
      // This is so we can implement deleg
      const delegateHandler = e => {
        if (isTarget(e.target, delegate, target)) {
          const data = e && e.detail;
          handler.call((delegate ? e.target : target), e, data);

          if (once) {
            target.removeEventListener(eventName, delegateHandler);
          }
        }
      };

      // We're keeping a reference to the original handler
      // so the consumer can later on `off` that specific handler
      delegateHandler.originalHandler = handler;

      target.addEventListener(eventName, delegateHandler);

      if (!once) {
        setEvent(target, eventName, delegateHandler);
      }
    };

    /**
     * Dispatches an event on a target, or calls its `on` function.
     * @param {EventTarget} target Event target to dispatch the event on.
     * @param {String} events space separated list of event names;
     * @param {Object} detail EventTarget Detail Object.
     * @param {Object} options
     */
    const dispatch = (target, events, detail, options) => {
      const hasDispatch = typeof target.dispatchEvent === "function";

      splitEvents(events).forEach(eventName => {
        const nativeEvent = isNativeEvent(eventName);
        let event;

        if (detail || !nativeEvent) {
          event = new CustomEvent(
            eventName,
            Object.assign({ detail, bubbles: true }, options)
          );
        } else {
          event = new Event(eventName, Object.assign({ bubbles: true }, options));
        }

        if (nativeEvent && typeof target[eventName] === "function") {
          target[eventName]();
        }

        if (!hasDispatch) {
          return;
        }
        target.dispatchEvent(event);
      });
    };

    /**
     * Stores target and its events for later access.
     * @param {EventTarget} target An event target to store.
     * @param {String} event Event Name.
     * @param {Function} handler Event handler function.
     */
    const setEvent = (target, event, handler) => {
      if (!target || !event || !handler) {
        return;
      }
      const targetIndex = savedEvents.findIndex(
        ([current]) => current === target
      );

      // Get the existing target reference, or default to an empty object.
      const [_, targetEvents] = savedEvents[targetIndex] || [target, {}];

      targetEvents[event] = targetEvents[event] || [];
      targetEvents[event].push(handler);

      if (targetIndex === -1) {
        savedEvents.push([target, targetEvents]);
      } else {
        savedEvents[targetIndex] = [target, targetEvents];
      }
    };

    /**
     * Removes Target events from storage
     * @param {EventTarget} target EventTarget to remove.
     * @param {String} [events] List of events to remove from storage.
     * @param {Function} [handler] Funtion to remove.
     */
    const deleteEvents = (target, events, handler) => {
      const targetIndex = savedEvents.findIndex(
        ([current]) => current === target
      );
      if (targetIndex === -1) {
        return;
      }

      const [, targetEvents] = savedEvents[targetIndex];

      const eventsArray = splitEvents(events);

      // Do this for each of the existing events for the current target.
      for (const event in targetEvents) {
        if (
          // * The consumer requested to remove the current event name
          //    or if the user did not specify an event name
          (eventsArray.indexOf(event) !== -1 || !events) &&
          // * And the current target has this event registered
          Object.prototype.hasOwnProperty.call(targetEvents, event) &&
          // * And it is an array (safeguard)
          Array.isArray(targetEvents[event])
        ) {
          // Filter out the events that the consumer wanted to remove
          targetEvents[event] = targetEvents[event].filter(currentHandler => {
            // If the consumer specified a specific handler to remove
            if (handler) {
              // and the handler doesn't match the current handler
              if (currentHandler.originalHandler !== handler) {
                // keep it in
                return true;
              } else {
                // filter it out and remove its listener;
                target.removeEventListener(event, currentHandler);
                return false;
              }
            } else {
              // Remove all handlers for current event name
              target.removeEventListener(event, currentHandler);
              return false;
            }
          });

          if (!events) {
            // Clear all the events
            delete targetEvents[event];
          }
        }
      }

      if (!events) {
        savedEvents.splice(targetIndex, 1);
      }
    };

    const bindEvents = (instance, options, [events, ...args]) => {
      if (!args.length) {
        // no handler. bye.
        return;
      }

      // One liner for:
      // [handler] = args
      // [delegate, handler] = args
      const { length, [length - 1]: handler, [length - 2]: delegate } = args;

      const eventsArray = splitEvents(events);
      return instance["forEach"](node =>
        eventsArray.forEach(event =>
          listen(node, event, handler, {
            ...options,
            delegate
          })
        )
      );
    };

  function on(...args) {
      return bindEvents(this, {}, args);
    }

  function once(...args) {
      return bindEvents(this, { once: true }, args);
    }

  function off(events, handler) {
      return this["forEach"](target => deleteEvents(target, events, handler));
    }

  function trigger(
      events,
      { data, options } = {}
    ) {
      return this["forEach"](target => dispatch(target, events, data, options));
    }

  var events = /*#__PURE__*/Object.freeze({
    __proto__: null,
    parseNode: parseNode,
    on: on,
    once: once,
    off: off,
    trigger: trigger
  });

  function splice(...args) {
      return Array.prototype.splice.apply(this, args);
    }

  function forEach(...args) {
      Array.prototype.forEach.call(this, ...args);
      return this;
    }

  function each(fn) {
      this["forEach"]((el, index) => {
          fn.call(el, index, el);
      });
      return this;
    }

  function add(...args) {
      args.forEach(selector => {
        const nodeList = parseNode(selector);

        nodeList.forEach(node => {
          for (let i = 0; i < this.length; i++) {
            if (this[i] === node) {
              return;
            }
          }
          this[this.length] = node;
          this.length++;
        });
      });

      return this;
    }

  function focus() {
  if(this.length) {
  let i = this.length - 1;
  this[i].focus();
  }
      return this;
    }

  function blur() {
  if(this.length) {
  let i = this.length - 1;
  this[i].blur();
  }
      return this;
    }

  function click() {
  		this["trigger"]('click');
  		return this;
  }

  function attr(name, value) {
  if(!value && typeof name === 'string') {
  return this.length > 0 ? this[0].getAttribute(name) : '';
  }
  let attrs = {};
  if(typeof name === 'string') {
  attrs[name] = value;
  } else {
  attrs = name;
  }
  this["forEach"](function(el) {
  for( let key in attrs) {
  if(el.setAttribute) {
  el.setAttribute(key, typeof attrs[key] === 'function' ? attrs[key].call(el) : attrs[key]);
  }
  }
  });
      return this;
    }

  function removeAttr(name) {
  let attrs = [];
  if(typeof name === 'string') {
  attrs.push(name);
  } else {
  attrs = name;
  }
  this["forEach"](function(el) {
  for(let i = 0, len = attrs.length; i < len; i++) {
  el.removeAttribute(attrs[i]);
  }
  });
      return this;
    }

  function addClass(className) {
  let classNames = className.split(' ');
      this["forEach"](function(el) {
  classNames.forEach(function(name) {
        el.classList && el.classList.add(name);
  });
      });
      return this;
    }

  function removeClass(className) {
      this["forEach"](function(el) {
        el.classList.remove(className);
      });
      return this;
    }

  function html(html) {
  if(typeof html === 'undefined') {
  let rt = '';
  this["forEach"](el => {
  rt += el.innerHTML;
  });
  return rt;
  }
  this["forEach"](function(el) {
  el.innerHTML = html;
  });
  return this;
    }

  function text(text) {
  if(typeof text === 'undefined') {
      let rt = '';
  this["forEach"](el => {
  rt += el.innerText;
  });
  return rt;
  }
  this["forEach"](function(el) {
  el.innerText = text;
  });
  return this;
    }

  function is(selector) {
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === 'undefined') return false;
    if (typeof selector === 'string') {
      if (el.matches) return el.matches(selector);
      else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

      compareWith = acc(selector);
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    } else if (selector === document) return el === document;
    else if (selector === window) return el === window;

    if (selector.nodeType || selector instanceof acc) {
      compareWith = selector.nodeType ? acc(selector) : selector;
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    }
    return false;
  }
  function parent(selector) {
  let v = acc();
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if (acc(this[i].parentNode)["is"](selector)) v.add(this[i].parentNode);
        } else {
          v.add(this[i].parentNode);
        }
      }
    }
    return v;
    }

  function parents(selector) {
    let parents = acc();
    for (let i = 0; i < this.length; i += 1) {
      let parent = this[i].parentNode;
      while (parent) {
        if (selector) {
          if (acc(parent)["is"](selector)) parents.add(parent);
        } else {
          parents.add(parent);
        }
        parent = parent.parentNode;
      }
    }
    return parents;
    }

  function find(selector) {
  let v = acc();
  this["forEach"](function(el) {
  el.nodeType && el.nodeType == 1 && v.add(el.querySelectorAll(selector));
      });
      return v;
    }

  function filterByText(text) {
  let v = acc();
  this["forEach"](function(el) {
  el.nodeType && el.nodeType == 1 && el.innerText.includes(text) && v.add(el);
      });
      return v;
    }

  function append(newEl) {
  this["forEach"](function(el) {
  if(typeof newEl === 'string') {
  el.insertAdjacentHTML('beforeend', newEl);
  } else if(newEl instanceof Node) {
  el.appendChild(newEl.cloneNode(true));
  }
  });
      return this;
    }

  function filter(selector) {
  let v = acc();
  this["forEach"](function(el) {
  if(typeof selector === 'function') {
  if(selector(el)) {
  v.add(el);
  }
  } else {
  if(el.matches(selector)) {
  v.add(el);
  }
  }
  });
      return v;
    }

  function not(selector) {
  let v = acc();
  this["forEach"](function(el) {
  if(typeof selector === 'function') {
  if(!selector(el)) {
  v.add(el);
  }
  } else {
  if(!el.matches(selector)) {
  v.add(el);
  }
  }
  });
      return v;
    }

  function get(index) {
      if(this.length < 1) {
          return null;
      }
      if(index < 0) {
          index += this.length;
      }
      if(index > this.length) {
          index = this.length - 1;
      }
      return this[index];
    }

  function eq(index) {
      return acc().add(this["get"](index));
    }

  function first() {
    return this.eq(0);
   }

  function last() {
    return this.eq(-1);
  }

  var methods = /*#__PURE__*/Object.freeze({
    __proto__: null,
    splice: splice,
    forEach: forEach,
    each: each,
    add: add,
    focus: focus,
    blur: blur,
    click: click,
    attr: attr,
    removeAttr: removeAttr,
    addClass: addClass,
    removeClass: removeClass,
    html: html,
    text: text,
    is: is,
    parent: parent,
    parents: parents,
    find: find,
    append: append,
    filter: filter,
    filterByText: filterByText,
    not: not,
    get: get,
    eq: eq,
    first: first,
    last: last
  });

  const Acc = function(...args) {
      this.length = 0;
      this.add(...args);
    };

  [methods, events].forEach((group) => {
    Object.keys(group).forEach((methodName) => {
      Acc.prototype[methodName] = group[methodName];
    });
  });

  //copy from jQuery source
  var preservedScriptAttributes = {
  	type: true,
  	src: true,
  	nonce: true,
  	noModule: true
  };

  function DOMEval( code, node, doc ) {
  	doc = doc || document;

  	var i, val,
  		script = doc.createElement( "script" );

  	script.text = code;
  	if ( node ) {
  		for ( i in preservedScriptAttributes ) {

  			// Support: Firefox <=64 - 66+, Edge <=18+
  			// Some browsers don't support the "nonce" property on scripts.
  			// On the other hand, just using `getAttribute` is not enough as
  			// the `nonce` attribute is reset to an empty string whenever it
  			// becomes browsing-context connected.
  			// See https://github.com/whatwg/html/issues/2369
  			// See https://html.spec.whatwg.org/#nonce-attributes
  			// The `node.getAttribute` check was added for the sake of
  			// `jQuery.globalEval` so that it can fake a nonce-containing node
  			// via an object.
  			val = node[ i ] || node.getAttribute && node.getAttribute( i );
  			if ( val ) {
  				script.setAttribute( i, val );
  			}
  		}
  	}
  	doc.head.appendChild( script ).parentNode.removeChild( script );
  }

  function isVisible(t) { //author by veg
  //return !!((t.tabIndex >= 0 || t.hasAttribute && t.hasAttribute('tabindex') && t.getAttribute('tabindex') == '-1') &&
  return !!(!t.hasAttribute('disabled') &&
  t.getAttribute('aria-hidden') !== 'true' &&
  t.offsetParent !== null);
  }


  /**
  function toFocus(focusSelector, op, rangeSelector) {
  let els = document.querySelectorAll(rangeSelector);
  let len = els.length;
  let ae = document.activeElement;
  let aeIndex = 0 ,index = 0;
  for(let i = 0; i < len; i++) {
  if(els[i] == ae) {
  aeIndex = index = i;
  break;
  }
  }
  let i = op == '+' ? index + 1 : index - 1;
  while(i != aeIndex) {
  if(els[i].classList.contains(focusSelector) && isVisible(els[i])) {
  index = i;
  break;
  }
  i = op == '+' ? i + 1 : i - 1;
  if(i >= len) {
  i = 0;
  }
  if(i < 0) {
  i = len -1;
  }
  }
  if(index == aeIndex) {
  //document.title = index;
  //return;
  }
  let el = els[index];
  let tagName = el.tagName.toLowerCase();
  let pels = ['div', 'p', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'form', 'img', 'nav', 'header', 'main', 'footer', 'section', 'aside'];
  if(pels.includes(tagName) || (tagName == 'a' && !el.hasAttribute('href'))) {
  if(!el.hasAttribute('tabindex')) {
  el.setAttribute('tabindex', '-1');
  }
  }
  el.focus();
  }

  function nextFocus(focusSelector, rangeSelector= '*') {
  toFocus(focusSelector, '+', rangeSelector);
  }

  function previousFocus(focusSelector, rangeSelector= '*') {
  toFocus(focusSelector, '-', rangeSelector);
  }


  function registerHotkeys(accesskeys) {
  accesskeys.forEach(function(a) {
  if(typeof a["accesskey"] === 'undefined') {
  return;
  }
  let focusSelector = 'accesskey-' + a["accesskey"].replace(/\+/g, '-');
  let op = a["toward"] == "next" ? "+" : "-";
  let rangeSelector = a["range"] == 'all' ? '*' : a.selector;
  acc(a["selector"])["addClass"](focusSelector);
  Mousetrap.bind(a["accesskey"], function() {
  toFocus(focusSelector, op, rangeSelector);
  return false;
  });
  });
  }
  */
  function gi(i, len, op) {
    let n = op == '+' ? +1 : -1;
    i = i + n;
    if (i >= len) {
      i = 0;
    }
    if (i < 0) {
      i = len - 1;
    }
    return i;
  }

  function _toFocus(el) {
    let tagName = el.tagName.toLowerCase();
    let tagNames = ['div', 'p', 'span', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'form', 'img', 'nav', 'header', 'main', 'footer', 'section', 'aside'];
    if (tagNames.includes(tagName) || (tagName == 'a' && !el.hasAttribute('href'))) {
      if (!el.hasAttribute('tabindex')) {
        el.setAttribute('tabindex', '-1');
      }
    }
    el.focus();
  }

  function toFocus(focusSelector, op) {
    let els = [...document.body.querySelectorAll('*')];
    let len = els.length;
    let aeIndex = Math.max(0, els.indexOf(document.activeElement));
    let i = aeIndex == 0 ? 0 : gi(aeIndex, len, op);
    do {
      if (els[i].matches(focusSelector) && isVisible(els[i])) {
        _toFocus(els[i]);
        break;
      }
      i = gi(i, len, op);
    } while ( i != aeIndex );
  }

  function nextFocus(selector) {
    toFocus(selector, '+');
  }

  function previousFocus(selector) {
    toFocus(selector, '-');
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    globalEval: DOMEval,
    isVisible: isVisible,
    toFocus: toFocus,
    nextFocus: nextFocus,
    previousFocus: previousFocus
  });

  var version = "1.0.3";

  const acc = (...args) => new Acc(...args);
  acc.version = version;

  Object.keys(utils).forEach((methodName) => {
      acc[methodName] = utils[methodName];
    });

  window.acc = acc;

})));
//alert(typeof acc);
function addDebug() {
acc('body').append('<div id="acc_debug_container"><textarea id="jscode" name="jscode"></textarea><button type="button" id="execbtn">exec</button></div>');
acc('#execbtn').on('click', function(e) {
var code = document.getElementById('jscode').value;
acc.globalEval(code);
});
}
function removeDebug() {
acc('#execbtn').off();
acc('#acc_debug_container').remove();
}
function accjsMutationObserver(proc) {
    let mo = new MutationObserver((records) => {
//num++;
//document.title = num;
proc();
//end records
}); //mo
    mo.observe(document.getElementById('root'), {
      'childList': true,
      'subtree': true
    });
}
function getAlt(src) {
var alt = '';
var faceData={
"呵呵":"/css/img/face/d_hehe",
"嘻嘻":"/css/img/face/d_xixi",
"哈哈":"/css/img/face/d_haha",
"太开心":"/css/img/face/d_taikaixin",
"亲亲":"/css/img/face/d_qinqin",
"酷":"/css/img/face/d_ku",
"拜拜":"/css/img/face/d_baibai",
"可爱":"/css/img/face/d_keai",
"馋嘴":"/css/img/face/d_chanzui",
"花心":"/css/img/face/d_huaxin",
"爱你":"/css/img/face/d_aini",
"汗":"/css/img/face/d_han",
"鄙视":"/css/img/face/d_bishi",
"怒":"/css/img/face/d_nu",
"失望":"/css/img/face/d_shiwang",
"害羞":"/css/img/face/d_haixiu",
"可怜":"/css/img/face/d_kelian",
"悲伤":"/css/img/face/d_beishang",
"泪":"/css/img/face/d_lei",
"闭嘴":"/css/img/face/d_bizui",
"委屈":"/css/img/face/d_weiqu",
"挖鼻屎":"/css/img/face/d_wabishi",
"思考":"/css/img/face/d_sikao",
"疑问":"/css/img/face/d_yiwen",
"嘘":"/css/img/face/d_xu",
"晕":"/css/img/face/d_yun",
"书呆子":"/css/img/face/d_shudaizi",
"阴险":"/css/img/face/d_yinxian",
"做鬼脸":"/css/img/face/d_zuoguilian",
"黑线":"/css/img/face/d_heixian",
"吃惊":"/css/img/face/d_chijing",
"衰":"/css/img/face/d_shuai",
"怒骂":"/css/img/face/d_numa",
"愤怒":"/css/img/face/d_fennu",
"左哼哼":"/css/img/face/d_zuohengheng",
"右哼哼":"/css/img/face/d_youhengheng",
"哼":"/css/img/face/d_heng",
"懒得理你":"/css/img/face/d_landelini",
"打哈气":"/css/img/face/d_dahaqi",
"钱":"/css/img/face/d_qian",
"偷笑":"/css/img/face/d_touxiao",
"鼓掌":"/css/img/face/d_guzhang",
"生病":"/css/img/face/d_shengbing",
"感冒":"/css/img/face/d_ganmao",
"困":"/css/img/face/d_kun",
"睡觉":"/css/img/face/d_shuijiao",
"抓狂":"/css/img/face/d_zhuakuang",
"吐":"/css/img/face/d_tu",
"顶":"/css/img/face/d_ding",
"男孩儿":"/css/img/face/d_nanhaier",
"女孩儿":"/css/img/face/d_nvhaier",
"兔子":"/css/img/face/d_tuzi",
"熊猫":"/css/img/face/d_xiongmao",
"猪头":"/css/img/face/d_zhutou",
"奥特曼":"/css/img/face/d_aoteman",
"互粉":"/css/img/face/f_hufen",
"神马":"/css/img/face/f_shenma",
"萌":"/css/img/face/f_meng",
"囧":"/css/img/face/f_jiong",
"给力":"/css/img/face/f_geili",
"心":"/css/img/face/l_xin",
"爱心传递":"/css/img/face/l_aixinchuandi",
"伤心":"/css/img/face/l_shangxin",
"帅":"/css/img/face/f_shuai",
"威武":"/css/img/face/f_v5",
"喜":"/css/img/face/f_xi",
"发红包":"/css/img/face/o_fahongbao",
"握手":"/css/img/face/h_woshou",
"耶":"/css/img/face/h_ye",
"赞":"/css/img/face/h_zan",ok:"/css/img/face/h_ok",good:"/css/img/face/h_good",
"弱":"/css/img/face/h_ruo",
"最差":"/css/img/face/h_zuicha",
"来":"/css/img/face/h_lai",
"不要":"/css/img/face/h_buyao",
"拳头":"/css/img/face/h_quantou",haha:"/css/img/face/h_haha",
"太阳":"/css/img/face/w_taiyang",
"月亮":"/css/img/face/w_yueliang",
"蛋糕":"/css/img/face/o_dangao",
"咖啡":"/css/img/face/o_kafei",
"干杯":"/css/img/face/o_ganbei",
"冰棍":"/css/img/face/o_binggun",
"西瓜":"/css/img/face/o_xigua",
"礼物":"/css/img/face/o_liwu",
"蜡烛":"/css/img/face/o_lazhu",
"鲜花":"/css/img/face/w_xianhua",
"落叶":"/css/img/face/w_luoye",
"绿丝带":"/css/img/face/o_lvsidai",
"红丝带":"/css/img/face/o_hongsidai",
"围观":"/css/img/face/o_weiguan",
"雪人":"/css/img/face/w_xueren",
"钟":"/css/img/face/o_zhong",
"微风":"/css/img/face/w_weifeng",
"下雨":"/css/img/face/w_xiayu",
"雪":"/css/img/face/w_xue",
"沙尘暴":"/css/img/face/w_shachenbao",
"浮云":"/css/img/face/w_fuyun",
"足球":"/css/img/face/o_zuqiu",
"手套":"/css/img/face/o_shoutao",
"围脖":"/css/img/face/o_weibo",
"温暖帽子":"/css/img/face/o_wennuanmaozi",
"自行车":"/css/img/face/o_zixingche",
"汽车":"/css/img/face/o_qiche",
"飞机":"/css/img/face/o_feiji",
"手机":"/css/img/face/o_shouji",
"音乐":"/css/img/face/o_yinyue",
"话筒":"/css/img/face/o_huatong",
"照相机":"/css/img/face/o_zhaoxiangji",
"电影":"/css/img/face/o_dianying",
"风扇":"/css/img/face/o_fengshan",
"实习":"/css/img/face/o_shixi"};
if(typeof src != 'string' || src == '') {
return alt;
}
for(var key in faceData) {
if(src.indexOf(faceData[key]) >= 0) {
alt = key;
break;
}
}
return alt;
}
function xmlyProcess() {
acc('iframe').attr('tabindex', '-1');
acc('.chat-text-input').attr('accesskey', 's');
acc('.time, .people-number, .pk-voice-content .header, .pk-voice-content .user-msg .left, .pk-voice-content .user-msg .right, .pk-voice-content .score').attr('tabindex','0').attr('role', 'text');
acc('.edit-chat-content .menu-btn').each(function(i) {
let menuButtons = ['表情', '图片', 'PK', '红包', '', '心愿单', '心爱值', '礼物周星', '萌新主播'];
if(this.tagName == "LABEL") {
acc(this).find('input').attr('aria-label', menuButtons[i]);
} else {
acc(this).attr({
"role": "button",
"tabindex": "0",
"aria-label": menuButtons[i]
});
}
});
acc('.ReactVirtualized__Grid, .swiper-pagination-bullet').removeAttr('tabindex');
acc('.task-detail').attr({"tabindex": "0", "role": "link"});
acc('span.switch-btn').attr('aria-label', function() {return acc(this).parents('.switch').text();}).attr('role', 'button');
acc('.upload-content .rc-upload').attr('aria-label', '选择封面图');
acc('.room-left-container, .room-center-container, .pk-voice-container, .room-right-container, .sound-container').attr('tabindex', '-1').attr('role', 'group');
acc('.room-left-container').attr('aria-label', '左侧');
acc('.room-center-container').attr('aria-label', '中间');
acc('.pk-voice-container').attr('aria-label', 'PK').attr('role', 'group');
acc('.room-right-container').attr('aria-label', '右侧');
acc('.sound-container').attr('aria-label', '音效');
acc('.modal-header-close-icon').attr('aria-label', '关闭').attr('tabindex','0').attr('role','button');
acc('.pk-mode-selection .mode-item .mode-image').attr('aria-label', function() {return acc(this).parents('.mode-item').text();}).attr('role', 'button').attr('tabindex','0');
acc('.chat-item-container .content img, .face-item img').attr('alt', function() { return getAlt(acc(this).attr('src')); });
acc('.album-list .album-container').attr('role','button').attr('tabindex','-1');
var gift_html = acc('.gift-item-container').last().html();
if(typeof gift_html != 'undefined') {
acc('#msaa_gift').html(gift_html.replace('头像', ''));
}
var barrage_html = acc('.barrage-item-container, .nobel-join-room-container').last().html();
if(typeof barrage_html != 'undefined') {
acc('#msaa_barrage').html(barrage_html.replace('头像', ''));
}
var message_html = acc('.chat-item-container').last().html();
if(typeof message_html != 'undefined') {
acc('#msaa_message').html(message_html.replace('头像', ''));
}
}
function setFocus(el) {
acc('.content img', el).attr('alt', function() {return getAlt(acc(this).attr('src')); });
el.setAttribute("tabindex", "-1");
el.setAttribute("role", "group");
var alts = [];
acc('.content img', el).each(function() {
alts.push(this.alt);
});
el.setAttribute('aria-label', el.innerText + alts.join(' '));
el.focus();
}

var acci = -1;
var acc_hotkey_f6_i = 0;
acc(document).on('keydown', function(e) {
//messages
//var chatItems = acc('.chat-item-container .message-user-join-room, .chat-item-container .content, .nobel-join-room-container, .barrage-container .barrage-content');
var chatItems = acc('.gift-item-container, .chat-item-container');
var len = chatItems.length;
if(e.altKey && e.keyCode == 37) {
setFocus(chatItems[0]);
acci = 0;
return false;
}
if(e.altKey && e.keyCode == 39) {
setFocus(chatItems[len -1]);
acci = len -1;
return false;
}
if(e.altKey && e.keyCode == 38 && acci > 0) {
acci--;
setFocus(chatItems[acci]);
return false;
}
if(e.altKey && e.keyCode == 40 && acci <= len-2) {
acci++;
setFocus(chatItems[acci]);
return false;
}

//debug
if(e.altKey && e.shiftKey && e.keyCode == 81) {
removeDebug();
return false;
}
if(e.altKey && e.keyCode == 81) {
addDebug();
return false;
}

//f6 切换区域
if(e.altKey && e.keyCode == 90 || e.keyCode == 117) {
var us = acc('.room-left-container, .room-center-container, .pk-voice-container, .room-right-container, .sound-container');
var len = us.length;
if(acc_hotkey_f6_i >= len) {
acc_hotkey_f6_i = 0;
}
us[acc_hotkey_f6_i].focus();
acc_hotkey_f6_i++;
if(acc_hotkey_f6_i >= len) {
acc_hotkey_f6_i = 0;
}
return false;
}
});
acc(document).on('click', 'span.switch-btn', function() {
acc(this).attr('aria-label', function() {return acc(this).parents('.switch').text();});
});
acc(document).on('keydown', 'span.switch-btn, .modal-header-close-icon', function(e) {
if(e.keyCode == 32 || e.keyCode == 13) {
acc(this).click();
return false;
}
});
acc(document).on('click', '.start-live, .stop-btn, .save-btn, .btn-group button, .income-ranking, .line button, .avatar, .edit-chat .red-env-btn, .edit-chat .sen-hot-btn, .edit-chat .pk-btn', function(e) {
setTimeout(function() {
acc('.modal-container').attr({
"role": "dialog",
"tabindex": "-1"
});
acc('.modal-container').last().focus();
}, 500);
});
acc('body').append('<div id="msaa_message" role="button" tabindex="0">请用争渡读屏监视这个按钮(消息)</div><div id="msaa_gift" role="button" tabindex="0">请用争渡读屏监视这个按钮(礼物)</div><div id="msaa_barrage" role="button" tabindex="0">请用争渡读屏监视这个按钮(弹幕)</div>');
accjsMutationObserver(xmlyProcess);
